/*****************************************************************************
* Model: cdb_usb.qm
* File:  ./bsp.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::bsp.c} ..............................................................*/
#include "qp_port.h"
#include "bsp.h"
#include "cdb_usb.h"

#include <pps.h>

Q_DEFINE_THIS_FILE


/* MCU configuration bits */
_CONFIG1
(
   JTAGEN_OFF     // JTAG Disabled
   & GCP_OFF      // Code Protect Disabled
   & GWRP_OFF     // Write Protect Disabled
   & FWDTEN_OFF   // Watchdog Timer Disabled
   & WINDIS_OFF   // Windowed Watchdog Timer Disabled
)

_CONFIG2
(
   IESO_ON          // Two Speed Start-up
   //& PLL96MHZ_ON    // 96MHz PLL Enabled
   & PLLDIV_DIV3    //input clock divided by 3 to get 4MHz
   & FNOSC_PRIPLL   //FNOSC_FRC //FNOSC_PRIPLL   //primary clock with PLL
   & POSCMOD_HS     //POSCMOD_NONE //POSCMOD_HS
)
_CONFIG3
(
  //SOSCSEL_IO
  SOSCSEL_EC
)
//_CONFIG4
//(
//  RTCOSC_LPRC           //RTCC Source
//)


                                 /* frequency of the oscillator */
#define FOSC_HZ                 32000000.0
                                       /* instruction cycle clock frequency */
#define FCY_HZ                  (FOSC_HZ / 2.0)

#define FCY FCY_HZ

#define BAUD_RATE_CONSOLE 115200UL
//Console TX buffer - must be power of 2
#define CONSOLE_TX_BUFSIZE 64
#define CONSOLE_TX_BUFMASK ( CONSOLE_TX_BUFSIZE - 1 )

#if ( CONSOLE_TX_BUFSIZE & CONSOLE_TX_BUFMASK )
#error Serial Tx Buffer size is not a power of 2
#endif


                 /* system clock tick period in CPU clocks / TMR2 prescaler */
#define BSP_TMR2_PERIOD         ((uint16_t)(FCY_HZ / BSP_TICKS_PER_SEC))

                                    /* controlling the LED on CDB port d.2 */

#ifdef Q_SPY
    static uint32_t l_tickTime;                        /* timestamp at tick */
    static uint8_t const l_T2Interrupt = 0;

    enum AppRecords {                 /* application-specific trace records */
        A1_STAT = QS_USER
    };

#endif

/* Variables */
//Serial console
const char* ConsoleTx_Buf[ CONSOLE_TX_BUFSIZE ];
uint8_t ConsoleTx_Head;
volatile uint8_t ConsoleTx_Tail;    //interrupt changes this
static const char* pPrintStr;   //stores a string being output

//USB

static BDT_ENTRY __attribute__ ((aligned(512))) BDT[2];
#define BDT_IN    (&BDT[0])
#define BDT_OUT   (&BDT[1])

/* ISRs --------------------------------------------------------------------*/

//NME

/*${ISR::_AddressError} ....................................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _AddressError(void) {
    while(1);    //Address error
}
/*${ISR::_StackError} ......................................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _StackError(void) {
    while(1);
}

/*${ISR::_T2Interrupt} .....................................................*/
void  __attribute__((__interrupt__, auto_psv)) _T2Interrupt(void) {
        _T2IF = 0;                              /* clear Timer 2 interrupt flag */

    #ifdef Q_SPY
        l_tickTime += BSP_TMR2_PERIOD;             /* account for TMR2 overflow */
    #endif

    QF_TICK(&l_T2Interrupt);          /* handle all armed time events in QF */
}
/*${ISR::_U2RXInterrupt} ...................................................*/
void  __attribute__((__interrupt__, auto_psv)) _U2RXInterrupt(void) {
        //    U2STAbits.FERR = 0;
        //    U2STAbits.OERR = 0;
        while( U2STAbits.URXDA == 1 ) {
            MenuSelectEvt* mse = Q_NEW(MenuSelectEvt, MENU_SELECT_SIG);
            mse->key = U2RXREG;
            QACTIVE_POST( AO_CLI, (QEvt*)mse, &l_U2RXInterrupt );
        }

        _U2RXIF = 0;
        //Input can be paced by disabling interrupt here and re-enabling in &Console
}
/*${ISR::_U2TXInterrupt} ...................................................*/
void  __attribute__((__interrupt__, auto_psv)) _U2TXInterrupt(void) {
        while( U2STAbits.UTXBF == 0 ) {    //UART buffer available

            if( *pPrintStr ) {             //previous string not completed
                U2TXREG = *pPrintStr++;
            }//if( *pPrintStr...
            else {                         //get next string

                if( ConsoleTx_Head != ConsoleTx_Tail ) {    //data available

                    ConsoleTx_Tail++;
    #if CONSOLE_TX_BUFMASK < 255
                    ConsoleTx_Tail &= CONSOLE_TX_BUFMASK;
    #endif //CONSOLE_TX_BUFMASK < 255

                    pPrintStr = ConsoleTx_Buf[ ConsoleTx_Tail ];

                }//if( ConsoleTx_Head != ConsoleTx_Tail...
                else {    //queue empty

                    _U2TXIE = 0;    //disable interrupt
                    return;    //IF not cleaned - bug?
                }
            }//else - get next string
        }//while( U2STAbits.UTXBF == 0...

        _U2TXIF = 0;
}
/*${ISR::_U2ErrInterrupt} ..................................................*/
void  __attribute__((__interrupt__, auto_psv)) _U2ErrInterrupt(void) {
    _U2ERIF = 0;
}
/*${ISR::_USB1Interrupt} ...................................................*/
void __attribute__((__interrupt__, auto_psv)) _USB1Interrupt(void) {
    static const QEvt detachEvt = { USB_DEV_DETACH_SIG, 0U, 0U };
    static const QEvt attachEvt = { USB_DEV_ATTACH_SIG, 0U, 0U };


           //Attach/detach interrupts are level. As soon as one of attach/detach occured
            //the corresponding interrupt is disabled and the other one is enabled

            //Attach
            if( _ATTACHIE && _ATTACHIF ) {  //interrupt both enabled and occured
                _ATTACHIE = 0;              //disable attach interrupt
                U1IR = ( bmINT_ATTACH | bmINT_DETACH );
                //_DETACHIE = 1;              //enable detach interrupt
    //           QACTIVE_POST(AO_USBhost, &attachEvt, &l_USBInterrupt);
                QF_PUBLISH( &attachEvt, &l_USBInterrupt );

            }//Attach

            //Detach
            if( _DETACHIE && _DETACHIF ) {   //interrupt both enabled and occured
                _DETACHIE = 0;               //disable detach interrupt
                U1IR = ( bmINT_DETACH | bmINT_ATTACH );
                //_ATTACHIE = 1;               //enable attach interrupt
                QF_PUBLISH( &detachEvt, &l_USBInterrupt );

            }//Detach

        _USB1IF = 0;  //clear USB interrupt
}

/* Private functions */

/*${BSP::Console_init} .....................................................*/
static void Console_init(void) {
     uint8_t tmpdata;

       U2MODE = 0x0008;                                /* enable high baud rate */
       U2STAbits.UTXISEL1 = 1;                         /* interrupt on empty FIFO */
       U2BRG  = ((FCY / 4 / BAUD_RATE_CONSOLE) - 1);    /* baud rate generator */

       _U2TXIP = 1; //serial interrupt priority
       _U2RXIP = 1;
       _U2ERIP = 1;
       U2MODEbits.UARTEN = 1;    //UART then Tx - in that order!
       U2STAbits.UTXEN   = 1;

       tmpdata = U2RXREG;       //clear RX errors
       U2STAbits.FERR = 0;
       U2STAbits.OERR = 0;

        //Set serial console pins
        PPSUnLock;
        PPSOutput( PPS_RP21, PPS_U2TX );    //hardcoded
        PPSInput( PPS_U2RX, PPS_RP26 );     //todo - make less cryptic
        //PPSOutput( CONSOLE_TX_PIN, PPS_U2TX );
        //PPSInput( PPS_U2RX, CONSOLE_RX_PIN );

        TRISGbits.TRISG7 = 1;    //set RX to input. todo - make less hardcoded

        PPSLock;

        ConsoleTx_Head = 0;
        ConsoleTx_Tail = 0;

        return;
}
/*${BSP::USB_init} .........................................................*/
static void USB_init(void) {
        //do not turn on VBUS power here!

            U1BDTP1 = (uint16_t)(&BDT) >> 8;    //initialize the buffer descriptor table pointer

            U1IE = 0;        //disable all USB interrupts
            U1IR = 0xff;     //clear interrupts
            U1OTGIE = 0;
            U1OTGIR = 0xff;
            U1EIE = 0;     //disable USB error interrupts
            U1EIR = 0xff;  //clear USB error interrupts

            U1CON = ( bmHOST | bmSOF_DISABLE );
            U1CON = ( bmHOST | bmPPONG_RESET | bmSOF_DISABLE );    //reset ping-pong buffers
            U1CON = ( bmHOST | bmSOF_DISABLE );                    //release ping-pong buffers from reset

            U1OTGCON = ( bmDP_PULLDOWN | bmDM_PULLDOWN );          //Pull down D+, D-

            U1CNFG1 = bmPPONG_NO_PPONG;  //no ping-pong buffers

            U1CNFG2 = ( bmVBUS_BOOST_DISABLE | bmVBUS_COMPARE_ENABLE | bmXCVR_ENABLE );

            //full speed
            U1ADDR = 0;
        //    _LSPD = 0;

            //U1SOF = SOF_THRESHOLD_64;
            //U1SOF = SOF_THRESHOLD_32;

            //U1SOF = 0xf0;

            U1PWRC = ( bmNORMAL_OPERATION | bmENABLE );    //enable USB module

            U1EP0bits.RETRYDIS = 1;    //disable NAK retries
            //U1EP0bits.EPHSHK = 1;       //enable endpoint handshake

            U1EP1  = USB_EP_DISABLE;  //disable all enppoints past 0
            U1EP2  = USB_EP_DISABLE;
            U1EP3  = USB_EP_DISABLE;
            U1EP4  = USB_EP_DISABLE;
            U1EP5  = USB_EP_DISABLE;
            U1EP6  = USB_EP_DISABLE;
            U1EP7  = USB_EP_DISABLE;
            U1EP8  = USB_EP_DISABLE;
            U1EP9  = USB_EP_DISABLE;
            U1EP10 = USB_EP_DISABLE;
            U1EP11 = USB_EP_DISABLE;
            U1EP12 = USB_EP_DISABLE;
            U1EP13 = USB_EP_DISABLE;
            U1EP14 = USB_EP_DISABLE;
            U1EP15 = USB_EP_DISABLE;

            /* enable bidirectional transfers and handshake */
            U1EP0bits.EPCONDIS = 0;     //enable SETUP on endpoint
            U1EP0bits.EPRXEN = 1;
            U1EP0bits.EPTXEN = 1;
            U1EP0bits.EPHSHK = 1;


            _USB1IF = 0;  //clear USB interrupt
            //SET_USBINT_PRIO();

            U1EIE = 0xff; //enable all errors


            //_UERRIE = 1;    //enable USB Error interrupt
            //_TRNIE = 1;     //enable token processing complete inrterupt

            //attach/detach interrupts are enabled in USB Tasks SM
}

/* Public functions */

/*${BSP::BSP_init} .........................................................*/
void BSP_init(void) {
        //REFOCONbits.ROEN = 1;   //output CPU clock for testing

    // PIC24FJ256GB206 doesn't have port A
        TRISB = 0;
        TRISC = 0;
        TRISD = 0;
        TRISE = 0;
        TRISF = 0;
        TRISG = 0;
        //ODCBbits.ODB9 = 1;    //open-drain
        PORTB = 0;
        //VBUS_ON();
        //AD1PCFGL = 0xffff;    //analog off

    // PIC24FJ256GB206 turns off analog differently
        ANSB = 0;
        ANSC = 0;
        ANSD = 0;
        //ANSE = 0;
        ANSF = 0;
        ANSG = 0;
        //AD1PCFGbits.PCFG10 = 1;

        //Set serial console pins
        //PPSUnLock;
        //PPSOutput(PPS_RP5, PPS_U2TX);
        //PPSInput(PPS_U2RX, PPS_RP6);
        //PPSLock;

        Console_init();
        USB_init();
}
/*${BSP::Console_printStr} .................................................*/
void Console_printStr(const char* str) {
     uint8_t tmphead = ConsoleTx_Head + 1;

    #if CONSOLE_TX_BUFMASK < 255
        tmphead &= CONSOLE_TX_BUFMASK;
    #endif

        while( tmphead == ConsoleTx_Tail ) {}     //this line blocks! return from the brackets

        ConsoleTx_Buf[ tmphead ] = /*(const uint8_t*)*/str;

        ConsoleTx_Head = tmphead;

        if( _U2TXIE == 0) {    //trigger interrupt
            _U2TXIF = 1;
            _U2TXIE = 1;
        }
}
/*${BSP::Console_printNum} .................................................*/
void Console_printNum(uint32_t num, uint8_t base) {
    #define CHAR_BUFSIZE 33
     const char* const numchars[] = {"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"};
     const char* buf[CHAR_BUFSIZE];
     const char** pStr = &(buf[CHAR_BUFSIZE-1]);

        do {

            *(--pStr) = numchars[num % base];

            num /= base;
        } while( num != 0 );

        while( pStr < &buf[CHAR_BUFSIZE-1] ) {    //copy the buffer into the queue

            Console_printStr( *pStr++ );
        }
}
/*${BSP::Console_printRoll} ................................................*/
void Console_printRoll(void) {
    #define IDX_MASK 3
     const char* const rollchar[4] = {"/","-","\\","|"};
     static uint8_t idx = 0;

        Console_printStr("\x08");    //backspace

        Console_printStr( rollchar[idx++] );

        idx &= IDX_MASK;
}

/* QP support functions */

/*${BSP::Q_onAssert} .......................................................*/
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
        (void)file;                                   /* avoid compiler warning */
        (void)line;                                   /* avoid compiler warning */
        LED_ON();
        QF_INT_DISABLE();             /* make sure that interrupts are disabled */
        for (;;) {
        }
}
/*${BSP::QF_onStartup} .....................................................*/
void QF_onStartup(void) {
        T2CON = 0x0000U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1 */
        TMR2  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
        PR2   = (uint16_t)(BSP_TMR2_PERIOD - 1U);              /* Timer2 period */
        //_T2IP = TIMER2_ISR_PRIO;              /* set Timer 2 interrupt priority */
        _T2IF = 0;                           /* clear the interrupt for Timer 2 */
        _T2IE = 1;                              /* enable interrupt for Timer 2 */
        T2CONbits.TON = 1;                                     /* start Timer 2 */

        //do not enable console tx interrupt here!
        _U2RXIF = 0;
        _U2ERIF = 0;
        _U2RXIE = 1;

        _USB1IE = 1;  //enable USB Interrupt
}
/*${BSP::QF_onCleanup} .....................................................*/
void QF_onCleanup(void) {
    /* empty */
}
/*${BSP::QF_onIdle} ........................................................*/
void QF_onIdle(void) {
    /* entered with interrupts disabled, NOTE01 */

        /* NOTE: not enough LEDs on the Microstick II board to implement
        *  the idle loop activity indicator ...
        */
        //LED_ON ();
        //LED_OFF();

    #ifdef Q_SPY
        QF_INT_ENABLE();                       /* enable interrupts, see NOTE01 */

        while (U2STAbits.UTXBF == 0U) {                  /* TX Buffer not full? */
            uint16_t b;

            QF_INT_DISABLE();
            b = QS_getByte();
            QF_INT_ENABLE();

            if (b == QS_EOD) {                          /* End-Of-Data reached? */
                break;                                 /* break out of the loop */
            }
            U2TXREG = (uint8_t)b;   /* stick the byte to TXREG for transmission */
        }
    #elif defined NDEBUG
        __asm__ volatile("disi #0x0001");
        Idle();                          /* transition to Idle mode, see NOTE02 */
    #else
        QF_INT_ENABLE();                       /* enable interrupts, see NOTE01 */
    #endif
}


#ifdef Q_SPY

#define QS_BUF_SIZE        1024
#define QS_BAUD_RATE       38400.0

/* QS functions */

/*${BSP::QS_onStartup} .....................................................*/
uint8_t QS_onStartup(void const* arg) {
     static uint8_t qsBuf[QS_BUF_SIZE];            /* buffer for Quantum Spy */

        QS_initBuf(qsBuf, sizeof(qsBuf));     /* initialize the QS trace buffer */

                     /* initialize the UART2 for transmitting the QS trace data */
        RPOR5bits.RP11R = 5;                         /* Assign U2TX To Pin RP11 */
        U2STA  = 0x0000U;                        /* use default settings of 8N1 */
        U2MODE = 0x0008U;                              /* enable high baud rate */
        U2BRG  = (uint16_t)((FCY_HZ / (4.0 * QS_BAUD_RATE)) - 1.0 + 0.5);
        U2MODEbits.UARTEN = 1;
        U2STAbits.UTXEN   = 1;
                                                     /* setup the QS filters... */
        QS_FILTER_ON(QS_ALL_RECORDS);

    //    QS_FILTER_OFF(QS_QEP_STATE_EMPTY);
    //    QS_FILTER_OFF(QS_QEP_STATE_ENTRY);
    //    QS_FILTER_OFF(QS_QEP_STATE_EXIT);
    //    QS_FILTER_OFF(QS_QEP_STATE_INIT);
    //    QS_FILTER_OFF(QS_QEP_INIT_TRAN);
    //    QS_FILTER_OFF(QS_QEP_INTERN_TRAN);
    //    QS_FILTER_OFF(QS_QEP_TRAN);
    //    QS_FILTER_OFF(QS_QEP_dummyD);

        QS_FILTER_OFF(QS_QF_ACTIVE_ADD);
        QS_FILTER_OFF(QS_QF_ACTIVE_REMOVE);
        QS_FILTER_OFF(QS_QF_ACTIVE_SUBSCRIBE);
        QS_FILTER_OFF(QS_QF_ACTIVE_UNSUBSCRIBE);
        QS_FILTER_OFF(QS_QF_ACTIVE_POST_FIFO);
        QS_FILTER_OFF(QS_QF_ACTIVE_POST_LIFO);
        QS_FILTER_OFF(QS_QF_ACTIVE_GET);
        QS_FILTER_OFF(QS_QF_ACTIVE_GET_LAST);
        QS_FILTER_OFF(QS_QF_EQUEUE_INIT);
        QS_FILTER_OFF(QS_QF_EQUEUE_POST_FIFO);
        QS_FILTER_OFF(QS_QF_EQUEUE_POST_LIFO);
        QS_FILTER_OFF(QS_QF_EQUEUE_GET);
        QS_FILTER_OFF(QS_QF_EQUEUE_GET_LAST);
        QS_FILTER_OFF(QS_QF_MPOOL_INIT);
        QS_FILTER_OFF(QS_QF_MPOOL_GET);
        QS_FILTER_OFF(QS_QF_MPOOL_PUT);
        QS_FILTER_OFF(QS_QF_PUBLISH);
        QS_FILTER_OFF(QS_QF_NEW);
        QS_FILTER_OFF(QS_QF_GC_ATTEMPT);
        QS_FILTER_OFF(QS_QF_GC);
    //    QS_FILTER_OFF(QS_QF_TICK);
        QS_FILTER_OFF(QS_QF_TIMEEVT_ARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_AUTO_DISARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_DISARM_ATTEMPT);
        QS_FILTER_OFF(QS_QF_TIMEEVT_DISARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_REARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_POST);
        QS_FILTER_OFF(QS_QF_CRIT_ENTRY);
        QS_FILTER_OFF(QS_QF_CRIT_EXIT);
        QS_FILTER_OFF(QS_QF_ISR_ENTRY);
        QS_FILTER_OFF(QS_QF_ISR_EXIT);

        return (uint8_t)1;            /* indicate successfull QS initialization */

}
/*${BSP::QS_onCleanup} .....................................................*/
void QS_onCleanup(void) {
    /* empty */
}
/*${BSP::QS_onFlush} .......................................................*/
void QS_onFlush(void) {
     uint16_t b;
        while ((b = QS_getByte()) != QS_EOD) { /* next QS trace byte available? */
            while (U2STAbits.UTXBF != 0U) {                  /* TX Buffer full? */
            }
            U2TXREG = (uint8_t)b;   /* stick the byte to TXREG for transmission */
        }
}
/*${BSP::QS_onGetTime} .....................................................*/
QSTimeCtr QS_onGetTime(void) {
        if (_T2IF == 0) {

            return l_tickTime + (uint32_t)TMR2;

        } else {

            return l_tickTime + BSP_TMR2_PERIOD + (uint32_t)TMR2;
        }
}


#endif                                                             /* Q_SPY */


